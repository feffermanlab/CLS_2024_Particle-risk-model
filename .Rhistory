Rb <- Community_output$R[day]*delt
#Sb, Ib, Rb are the number of Susceptible, Infected and Recovered individuals that will be in the building
#initial conditions for each room. Randomly distribute individuals throughout rooms
# first asign a random number between o and one for each room,
#broken up by S, I, and R
S_x <- c(runif(N_rooms, min = 0, max = 1))
I_x <- c(runif(N_rooms, min = 0, max = 1))
R_x <- c(runif(N_rooms, min = 0, max = 1))
#normalize and then assign the correct amount of S, I, and R based on Sb, Ib, and Rb
S_x <- (S_x/sum(S_x))*Sb
I_x <- (I_x/sum(I_x))*Ib
R_x <- (R_x/sum(R_x))*Rb
# we start with no particles in the building
P_x <- c(rep(0,N_rooms))
Init_conds <-c(S=S_x, I = I_x, R = R_x, P = P_x)
return(data.frame(S_x=S_x,I_x=I_x,R_x=R_x,P_x=P_x))
}
# creates a square matrix with entries being random numbers from 0 to 1 and
#then eliminates transitions that don't exist based on the adjacency matrix
#can be used for both people transition matrices and particle transitions matrices
# right now the people and particles use the same adjacency matrix -- this could be
# changed by giving the function a different adjacency matrix - this would be good if
# we want to take into account ventilation routes.
Create_T_Matrix <-function(adjacency_matrix_to_use){
#set.seed(123145) # <- easier for finding debugging
T_mov <- data.frame(matrix(runif(N_rooms^2), nrow = N_rooms))
T_mov <- adjacency_matrix_to_use*T_mov
T_mov_norm <- t(apply(T_mov, 1, function(x) x / sum(x)))
T_mov <-T_mov_norm
return(T_mov)
}
#function that uses the adjacency matrix to calculate distances and then sets transition rates
#such that moving closer to the outside room has higher rates.
End_of_day_T_function <- function(adjacency_matrix_to_use){
#set.seed(12312145)
Random_T_mov <- Create_T_Matrix(adjacency_matrix_to_use = adjacency_matrix_to_use)
End_day_T_mov <- Random_T_mov
distance_vector <- distances(graph_to_use, to = as.character(nrow(adjacency_matrix_to_use)))
for(i in 1:N_rooms){
for(j in 1:N_rooms){
if (distance_vector[j] < distance_vector[i]) {
End_day_T_mov[i,j] <- 10
}else{
End_day_T_mov[i,j] <- 0.5
}
}
}
End_day_T_mov <- End_day_T_mov*adjacency_matrix_to_use
return(End_day_T_mov)
}
#
Create_Particle_T_Matrix<-function(adjacency_matrix_to_use,prop){
#set.seed(12312145) # <- easier for finding debugging
theta_mov <- data.frame(matrix(runif(N_rooms^2), nrow = N_rooms))
theta_mov <- adjacency_matrix_to_use*theta_mov
#diag(theta_mov) <- 0
theta_mov_prop <- prop #proportion of particles that move
theta_mov_norm <- t(apply(theta_mov, 1, function(x) x / sum(x)))
theta_mov <- theta_mov_prop*theta_mov_norm
return(theta_mov)
}
# Functions for finding the flux in and flux out of a room - specifically for people - different for
# people/particles because only so many people can fit in a room however particles don't have a limit.
flux_in_people <- function(N_rooms, Transition_matrix,State,Room_pops,Carrying_capacity,t){
all_room_change <- c(seq(N_rooms))
for(x in 1:N_rooms){
flux_in_temp <- 0
for(i in 1:N_rooms){
flux_in_temp <- flux_in_temp + State[i]*Transition_matrix[i,x]*(1-(Room_pops[x]/Carrying_capacity[x]))
}
all_room_change[x] <- flux_in_temp
}
test <- c(M = as.vector(all_room_change))
return(test)
}
flux_out_people <- function(N_rooms, Transition_matrix,State,Room_pops,Carrying_capacity){
all_room_change <- c(seq(N_rooms))
for(x in 1:N_rooms){
flux_out_temp <- 0
for(i in 1:N_rooms){
flux_out_temp <- flux_out_temp + State[x]*Transition_matrix[x,i]*(1-(Room_pops[i]/Carrying_capacity[i]))
}
all_room_change[x] <- flux_out_temp
}
test <- c(M = as.vector(all_room_change))
return(test)
}
# Functions for finding the flux in and the flux out for particles
flux_in_particles <- function(N_rooms, Transition_matrix,State){
all_room_change <- c(seq(N_rooms))
for(x in 1:N_rooms){
flux_in_temp <- 0
for(i in 1:N_rooms){
flux_in_temp <- flux_in_temp + State[i]*Transition_matrix[i,x]
}
all_room_change[x] <- flux_in_temp
}
test <- c(M = as.vector(all_room_change))
return(test)
}
flux_out_particles <- function(N_rooms, Transition_matrix,State){
all_room_change <- c(seq(N_rooms))
for(x in 1:N_rooms){
flux_out_temp <- 0
for(i in 1:N_rooms){
flux_out_temp <- flux_out_temp + State[x]*Transition_matrix[x,i]
}
all_room_change[x] <- flux_out_temp
}
test <- c(M = as.vector(all_room_change))
return(test)
}
Particle_model <- function(t, x, parms,T_mov, theta_mov, adjacency_matrix_to_use,C){
ncompartment <- 4
n_rooms <- length(x)/ncompartment
S <- as.matrix(x[1:n_rooms])
I <- as.matrix(x[(n_rooms+1):(2*n_rooms)])
R <- as.matrix(x[(2*n_rooms+1):(3*n_rooms)])
P <- as.matrix(x[(3*n_rooms+1):(4*n_rooms)])
with(parms,{
dS <- as.matrix((flux_in_people(N_rooms, Transition_matrix =T_mov, State=S,Room_pops = (S+I+R),Carrying_capacity = C)) - flux_out_people(N_rooms, Transition_matrix = T_mov, State=S,Room_pops = (S+I+R),Carrying_capacity = C))
dI <- as.matrix((flux_in_people(N_rooms, Transition_matrix =T_mov, State=I,Room_pops = (S+I+R),Carrying_capacity = C)) - flux_out_people(N_rooms, Transition_matrix = T_mov, State=I,Room_pops = (S+I+R),Carrying_capacity = C))
dR <- as.matrix((flux_in_people(N_rooms, Transition_matrix =T_mov, State=R,Room_pops = (S+I+R),Carrying_capacity = C)) - flux_out_people(N_rooms, Transition_matrix = T_mov, State=R,Room_pops = (S+I+R),Carrying_capacity = C))
#last step will be the particle EQ
dP <- s*as.matrix(I) - a*as.matrix(P)*(S+I+R)+
as.matrix(as.matrix(flux_in_particles(N_rooms, theta_mov,State = P)) - as.matrix(flux_out_particles(N_rooms, theta_mov,State = P))) - d*as.matrix(P)
dt <- c(dS,dI,dR,dP)
return(list(dt))})
}
######################### Community simulation} ##############################
community_pop <- 100000
init_conds <- c(S = community_pop-1, I = 1, R = 0)
print(init_conds)
parms <- data.frame(bet =0.0000035 , gam = 1/21)
print(parms)
times <- seq(from = 1, to = 144, by = 1)
print(times)
Community_output <- data.frame(lsoda(y = init_conds, func = SIR_community_model,times = times, parms=parms))
Community_output %>% pivot_longer(cols = !time) %>% arrange(desc(time))%>%
ggplot(aes(x=time,y =value, color = name))+geom_line()+
scale_color_manual(name=NULL,values=c("blue","red","purple"),breaks = c("S","I","R"))+
theme_classic()+
labs(x= "Time (days)", y = "Number of individuals")+ggtitle("Community outbreak of pathogen")
############# Global variables #########
m <-4 #number of equations per room
day <- 31 # what day from the community model do we want to model and base our proportion of Susceptible, Infected, and Recovered individuals do we want to look at
Prop_full <- 0.8
day_start <- 0
day_duration <- 8
Maxtime <- 24*7
times <- seq(from = 0, to = Maxtime, by = 0.2)
# units of particle equation are not in raw number of particles but instead in volumetric air.
# units are Liters/time
#### Decay ####
# particles are estimated to fall within 20 minutes so
# so d = 1/20
#### Absorption ####
# estimated 10L/min
# going to use minutes
# going to use nanoparticles since that is what shedding is in
#### Shedding ####
#seems to be 3 nanoLiters/min
# if in L so going to convert to liters
# 10^9 nanoliters in 1 L
# so 3*10^-9 L per minute
# if hours that becomes 1.8*10^-7
#"correct units" = Liters = (s=1.8*10^-7,a=600, d=3)
#NanoLiters = (180,a =6*10^11, d=3)
#parms_Liters <- data.frame(s=1.8*10^-7,a=600, d=3)
#parms_nanoLiters <- data.frame(180,a =6*10^11, d=3)
parms <-data.frame(s=100,a=5, d=3)
####################  First example - church #############################
church_adjacency_matrix <- matrix(c(c(0,rep(1,3),rep(0,8),rep(1,4),rep(0,31-17),1), #column 1 - main area / Hallway
c(1,0,0,1,rep(0,12),rep(1,4),rep(0,31-20)), # column 2 - Hallway
c(1,0,0,1,rep(0,4),rep(1,4),rep(0,31-12)), # column 3 - Hallway
c(1,1,1,0,1,0,1,1,rep(0,31-8)), #column 4 Main room
c(rep(0,3),1,0,1,0,1,rep(0,17),1,rep(0, 31-26)), # # column 5 Hallway
c(rep(0,4),1,0,1,rep(0,15),rep(1,5),0,1,1,0), # Column 6 Hallway
c(rep(0,3),1,0,1,0,1,rep(0,31-8)), # Column 7 Hallway
c(rep(0,3),1,1,0,1,rep(0,21-8),1,1,rep(0,31-22)), # Column 8 Hallway
rep(c(0,0,1,rep(0,31-3)),4), # columns 9-12
rep(c(1,rep(0,31-1)),4), # columns 13-16
rep(c(0,1,rep(0,31-2)),4), # columns 17-20
rep(c(rep(0,7),1,rep(0, 31-8)),2), # Columns 21 and 22
rep(c(rep(0,5),1,rep(0,31-6)),3), # columns 23-25
c(rep(0,4),1,1,rep(0,31-6)), # Column 26
c(rep(0,5),1,rep(0,21),1,rep(0,31-28)), # column 27
c(rep(0,26),1,rep(0,31-27)), # column 28
c(rep(0,5),1,rep(0,31-6)), # column 29
c(rep(0,5),1,1,rep(0,31-7)), # column 30
c(1,rep(0,30)) # column 31 -- Outside
),nrow=31, ncol = 31)
church_graph<- graph_from_adjacency_matrix(church_adjacency_matrix, mode = "undirected")
plot(church_graph)
#church_adjacency_matrix
#church_init_prob <- c(0,0.2,0,0.8,rep(0,nrow(church_adjacency_matrix)-4))
graph_to_use <- church_graph
adjacency_matrix_to_use <- church_adjacency_matrix
N_rooms <- ncol(adjacency_matrix_to_use) #number of rooms
Church_C <- c(20, #column 1 - main area / Hallway
5, # column 2 - Hallway
5, # column 3 - Hallway
200, #column 4 Main room
5, # # column 5 Hallway
7, # Column 6 Hallway - slightly bigger hallway
5, # Column 7 Hallway
5, # Column 8 Hallway
15, # comn 9
15, # column 10
15, #column 11
2, # column 12 janitors closet
15, # column 13
5, # column 14 - bathroom
15, # column 15
5, # column 16 - bathroom
15, # column 17
2, # column 18 - closet
15, # column 19
15, # column 20
2, # column 21 dressing room
2, # column 22 dressing room
4, # column 23 office
4, # column 24 office
4, # column 25 office
4, # column 26 office
5, # column 27 office - large
2, # column 28 small bathroom
4, # column 29 office
4 # column 30 office
) # column 31 -- Outside
Church_C <- c(Church_C,sum(Church_C))
#outside should only be able to hold the total capacity of the building
Building_max <- Church_C[N_rooms] #last room in C is the "outside" room
Max_capacity <- Prop_full*Building_max
delt <- Max_capacity/community_pop # proportionality constant ( what proportion of individuals from the community are in the building of interest)
# Community model - simple SIR model
SIR_community_model <- function(t, x, parms) {
S <- x[1]
I <- x[2]
R <- x[3]
with(parms, {
dS <- -bet*S*I
dI <- bet*S*I - gam*I
dR <- gam*I
dt <- c(dS,dI,dR)
return(list(dt))
})}
# This function sets the initial conditions for the building
#including randomly distributing individuals throughout the building/across rooms
#We assume that the proportion of S,I, and R in the community is proportional to
#the proportion of S, I, and R individuals in the building
Bld_setup_func <- function(Community_output,day, delt,N_rooms){
Building_ICs <- Community_output[day,] #Retrieves the number of S, I, and R individuals in the population at a particular day.
#delt is set below in the parameter declaration by taking into account
#the max capacity of the building and how full we set the building to be
Sb <- Community_output$S[day]*delt
Ib <- Community_output$I[day]*delt
Rb <- Community_output$R[day]*delt
#Sb, Ib, Rb are the number of Susceptible, Infected and Recovered individuals that will be in the building
#initial conditions for each room. Randomly distribute individuals throughout rooms
# first asign a random number between o and one for each room,
#broken up by S, I, and R
S_x <- c(runif(N_rooms, min = 0, max = 1))
I_x <- c(runif(N_rooms, min = 0, max = 1))
R_x <- c(runif(N_rooms, min = 0, max = 1))
#normalize and then assign the correct amount of S, I, and R based on Sb, Ib, and Rb
S_x <- (S_x/sum(S_x))*Sb
I_x <- (I_x/sum(I_x))*Ib
R_x <- (R_x/sum(R_x))*Rb
# we start with no particles in the building
P_x <- c(rep(0,N_rooms))
Init_conds <-c(S=S_x, I = I_x, R = R_x, P = P_x)
return(data.frame(S_x=S_x,I_x=I_x,R_x=R_x,P_x=P_x))
}
# creates a square matrix with entries being random numbers from 0 to 1 and
#then eliminates transitions that don't exist based on the adjacency matrix
#can be used for both people transition matrices and particle transitions matrices
# right now the people and particles use the same adjacency matrix -- this could be
# changed by giving the function a different adjacency matrix - this would be good if
# we want to take into account ventilation routes.
Create_T_Matrix <-function(adjacency_matrix_to_use){
#set.seed(123145) # <- easier for finding debugging
T_mov <- data.frame(matrix(runif(N_rooms^2), nrow = N_rooms))
T_mov <- adjacency_matrix_to_use*T_mov
T_mov_norm <- t(apply(T_mov, 1, function(x) x / sum(x)))
T_mov <-T_mov_norm
return(T_mov)
}
#function that uses the adjacency matrix to calculate distances and then sets transition rates
#such that moving closer to the outside room has higher rates.
End_of_day_T_function <- function(adjacency_matrix_to_use){
#set.seed(12312145)
Random_T_mov <- Create_T_Matrix(adjacency_matrix_to_use = adjacency_matrix_to_use)
End_day_T_mov <- Random_T_mov
distance_vector <- distances(graph_to_use, to = as.character(nrow(adjacency_matrix_to_use)))
for(i in 1:N_rooms){
for(j in 1:N_rooms){
if (distance_vector[j] < distance_vector[i]) {
End_day_T_mov[i,j] <- 10
}else{
End_day_T_mov[i,j] <- 0.5
}
}
}
End_day_T_mov <- End_day_T_mov*adjacency_matrix_to_use
return(End_day_T_mov)
}
#
Create_Particle_T_Matrix<-function(adjacency_matrix_to_use,prop){
#set.seed(12312145) # <- easier for finding debugging
theta_mov <- data.frame(matrix(runif(N_rooms^2), nrow = N_rooms))
theta_mov <- adjacency_matrix_to_use*theta_mov
#diag(theta_mov) <- 0
theta_mov_prop <- prop #proportion of particles that move
theta_mov_norm <- t(apply(theta_mov, 1, function(x) x / sum(x)))
theta_mov <- theta_mov_prop*theta_mov_norm
return(theta_mov)
}
# Functions for finding the flux in and flux out of a room - specifically for people - different for
# people/particles because only so many people can fit in a room however particles don't have a limit.
flux_in_people <- function(N_rooms, Transition_matrix,State,Room_pops,Carrying_capacity,t){
all_room_change <- c(seq(N_rooms))
for(x in 1:N_rooms){
flux_in_temp <- 0
for(i in 1:N_rooms){
flux_in_temp <- flux_in_temp + State[i]*Transition_matrix[i,x]*(1-(Room_pops[x]/Carrying_capacity[x]))
}
all_room_change[x] <- flux_in_temp
}
test <- c(M = as.vector(all_room_change))
return(test)
}
flux_out_people <- function(N_rooms, Transition_matrix,State,Room_pops,Carrying_capacity){
all_room_change <- c(seq(N_rooms))
for(x in 1:N_rooms){
flux_out_temp <- 0
for(i in 1:N_rooms){
flux_out_temp <- flux_out_temp + State[x]*Transition_matrix[x,i]*(1-(Room_pops[i]/Carrying_capacity[i]))
}
all_room_change[x] <- flux_out_temp
}
test <- c(M = as.vector(all_room_change))
return(test)
}
# Functions for finding the flux in and the flux out for particles
flux_in_particles <- function(N_rooms, Transition_matrix,State){
all_room_change <- c(seq(N_rooms))
for(x in 1:N_rooms){
flux_in_temp <- 0
for(i in 1:N_rooms){
flux_in_temp <- flux_in_temp + State[i]*Transition_matrix[i,x]
}
all_room_change[x] <- flux_in_temp
}
test <- c(M = as.vector(all_room_change))
return(test)
}
flux_out_particles <- function(N_rooms, Transition_matrix,State){
all_room_change <- c(seq(N_rooms))
for(x in 1:N_rooms){
flux_out_temp <- 0
for(i in 1:N_rooms){
flux_out_temp <- flux_out_temp + State[x]*Transition_matrix[x,i]
}
all_room_change[x] <- flux_out_temp
}
test <- c(M = as.vector(all_room_change))
return(test)
}
Particle_model <- function(t, x, parms,T_mov, theta_mov, adjacency_matrix_to_use,C){
ncompartment <- 4
n_rooms <- length(x)/ncompartment
S <- as.matrix(x[1:n_rooms])
I <- as.matrix(x[(n_rooms+1):(2*n_rooms)])
R <- as.matrix(x[(2*n_rooms+1):(3*n_rooms)])
P <- as.matrix(x[(3*n_rooms+1):(4*n_rooms)])
with(parms,{
dS <- as.matrix((flux_in_people(N_rooms, Transition_matrix =T_mov, State=S,Room_pops = (S+I+R),Carrying_capacity = C)) - flux_out_people(N_rooms, Transition_matrix = T_mov, State=S,Room_pops = (S+I+R),Carrying_capacity = C))
dI <- as.matrix((flux_in_people(N_rooms, Transition_matrix =T_mov, State=I,Room_pops = (S+I+R),Carrying_capacity = C)) - flux_out_people(N_rooms, Transition_matrix = T_mov, State=I,Room_pops = (S+I+R),Carrying_capacity = C))
dR <- as.matrix((flux_in_people(N_rooms, Transition_matrix =T_mov, State=R,Room_pops = (S+I+R),Carrying_capacity = C)) - flux_out_people(N_rooms, Transition_matrix = T_mov, State=R,Room_pops = (S+I+R),Carrying_capacity = C))
#last step will be the particle EQ
dP <- s*as.matrix(I) - a*as.matrix(P)*(S+I+R)+
as.matrix(as.matrix(flux_in_particles(N_rooms, theta_mov,State = P)) - as.matrix(flux_out_particles(N_rooms, theta_mov,State = P))) - d*as.matrix(P)
dt <- c(dS,dI,dR,dP)
return(list(dt))})
}
######################### Community simulation} ##############################
community_pop <- 100000
init_conds <- c(S = community_pop-1, I = 1, R = 0)
print(init_conds)
parms <- data.frame(bet =0.0000035 , gam = 1/21)
print(parms)
times <- seq(from = 1, to = 144, by = 1)
print(times)
Community_output <- data.frame(lsoda(y = init_conds, func = SIR_community_model,times = times, parms=parms))
Community_output %>% pivot_longer(cols = !time) %>% arrange(desc(time))%>%
ggplot(aes(x=time,y =value, color = name))+geom_line()+
scale_color_manual(name=NULL,values=c("blue","red","purple"),breaks = c("S","I","R"))+
theme_classic()+
labs(x= "Time (days)", y = "Number of individuals")+ggtitle("Community outbreak of pathogen")
############# Global variables #########
m <-4 #number of equations per room
day <- 31 # what day from the community model do we want to model and base our proportion of Susceptible, Infected, and Recovered individuals do we want to look at
Prop_full <- 0.8
day_start <- 0
day_duration <- 8
Maxtime <- 24*7
times <- seq(from = 0, to = Maxtime, by = 0.2)
# units of particle equation are not in raw number of particles but instead in volumetric air.
# units are Liters/time
#### Decay ####
# particles are estimated to fall within 20 minutes so
# so d = 1/20
#### Absorption ####
# estimated 10L/min
# going to use minutes
# going to use nanoparticles since that is what shedding is in
#### Shedding ####
#seems to be 3 nanoLiters/min
# if in L so going to convert to liters
# 10^9 nanoliters in 1 L
# so 3*10^-9 L per minute
# if hours that becomes 1.8*10^-7
#"correct units" = Liters = (s=1.8*10^-7,a=600, d=3)
#NanoLiters = (180,a =6*10^11, d=3)
#parms_Liters <- data.frame(s=1.8*10^-7,a=600, d=3)
#parms_nanoLiters <- data.frame(180,a =6*10^11, d=3)
parms <-data.frame(s=100,a=5, d=3)
####################  First example - church #############################
church_adjacency_matrix <- matrix(c(c(0,rep(1,3),rep(0,8),rep(1,4),rep(0,31-17),1), #column 1 - main area / Hallway
c(1,0,0,1,rep(0,12),rep(1,4),rep(0,31-20)), # column 2 - Hallway
c(1,0,0,1,rep(0,4),rep(1,4),rep(0,31-12)), # column 3 - Hallway
c(1,1,1,0,1,0,1,1,rep(0,31-8)), #column 4 Main room
c(rep(0,3),1,0,1,0,1,rep(0,17),1,rep(0, 31-26)), # # column 5 Hallway
c(rep(0,4),1,0,1,rep(0,15),rep(1,5),0,1,1,0), # Column 6 Hallway
c(rep(0,3),1,0,1,0,1,rep(0,31-8)), # Column 7 Hallway
c(rep(0,3),1,1,0,1,rep(0,21-8),1,1,rep(0,31-22)), # Column 8 Hallway
rep(c(0,0,1,rep(0,31-3)),4), # columns 9-12
rep(c(1,rep(0,31-1)),4), # columns 13-16
rep(c(0,1,rep(0,31-2)),4), # columns 17-20
rep(c(rep(0,7),1,rep(0, 31-8)),2), # Columns 21 and 22
rep(c(rep(0,5),1,rep(0,31-6)),3), # columns 23-25
c(rep(0,4),1,1,rep(0,31-6)), # Column 26
c(rep(0,5),1,rep(0,21),1,rep(0,31-28)), # column 27
c(rep(0,26),1,rep(0,31-27)), # column 28
c(rep(0,5),1,rep(0,31-6)), # column 29
c(rep(0,5),1,1,rep(0,31-7)), # column 30
c(1,rep(0,30)) # column 31 -- Outside
),nrow=31, ncol = 31)
church_graph<- graph_from_adjacency_matrix(church_adjacency_matrix, mode = "undirected")
plot(church_graph)
#church_adjacency_matrix
#church_init_prob <- c(0,0.2,0,0.8,rep(0,nrow(church_adjacency_matrix)-4))
graph_to_use <- church_graph
adjacency_matrix_to_use <- church_adjacency_matrix
N_rooms <- ncol(adjacency_matrix_to_use) #number of rooms
Church_C <- c(20, #column 1 - main area / Hallway
5, # column 2 - Hallway
5, # column 3 - Hallway
200, #column 4 Main room
5, # # column 5 Hallway
7, # Column 6 Hallway - slightly bigger hallway
5, # Column 7 Hallway
5, # Column 8 Hallway
15, # comn 9
15, # column 10
15, #column 11
2, # column 12 janitors closet
15, # column 13
5, # column 14 - bathroom
15, # column 15
5, # column 16 - bathroom
15, # column 17
2, # column 18 - closet
15, # column 19
15, # column 20
2, # column 21 dressing room
2, # column 22 dressing room
4, # column 23 office
4, # column 24 office
4, # column 25 office
4, # column 26 office
5, # column 27 office - large
2, # column 28 small bathroom
4, # column 29 office
4 # column 30 office
) # column 31 -- Outside
Church_C <- c(Church_C,sum(Church_C))
#outside should only be able to hold the total capacity of the building
Building_max <- Church_C[N_rooms] #last room in C is the "outside" room
Max_capacity <- Prop_full*Building_max
delt <- Max_capacity/community_pop # proportionality constant ( what proportion of individuals from the community are in the building of interest)
Church_setup <- Bld_setup_func(Community_output = Community_output,day = day,delt = delt,N_rooms =N_rooms)
church_graph <-church_graph %>% set_vertex_attr( "Infectious", value = Church_setup$I_x) %>%
set_vertex_attr("Room", value = seq(1:N_rooms))# +
Church_Init_conds <-c(S=Church_setup$S_x, I = Church_setup$I_x, R = Church_setup$R_x, P = Church_setup$P_x)
church_network <- ggplot(church_graph, aes(x = x, y = y, xend = xend, yend = yend))+
geom_edges(color = "grey75")+
geom_nodes(aes(size = Infectious), color = "#C21807")+
geom_nodetext_repel(aes(label=Room))+
theme_blank()+
scale_size(name = "Number of\nInfectious\npeople in\nrooms")+
labs(title = "Network representation of a church")+
theme(plot.title.position = "panel",
plot.title = element_text(hjust=1))
church_network
#Initialize Transition matrices, both people and particles
Church_T_mov <- Create_Particle_T_Matrix(adjacency_matrix_to_use = adjacency_matrix_to_use,prop = 0.9)
Church_theta_mov <- Create_Particle_T_Matrix(adjacency_matrix_to_use = adjacency_matrix_to_use,prop = 0.5)
Church_end_day_T_mov <- End_of_day_T_function(adjacency_matrix_to_use = adjacency_matrix_to_use)
End_of_day_T_mov_to_use <- Church_end_day_T_mov
Church_output <- data.frame(lsoda(y = Church_Init_conds, func = Particle_model,times = times, parms = parms,adjacency_matrix_to_use=adjacency_matrix_to_use,theta_mov =Church_theta_mov,T_mov = Church_T_mov,C =Church_C))
